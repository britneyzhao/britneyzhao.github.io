---
layout: post
title: Blog Post 1 - Visualization of NOAA Climate Data
---

This blog post will explain how to create a database and visualize quantitative data from this database with Python using `sqlite3`. 

## §1. Creating the Database

First, we must create the database containing information about the NOAA Climate. To do so, we will first import the appropriate modules and read the data into `pandas` DataFrames. We will need `sqlite3` to create the actual database, so let's import this module now as well. For this example, we will import data about climate stations and countries like so: 

```python
import pandas as pd
import sqlite3

#read csv files
stations = pd.read_csv("https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/noaa-ghcn/station-metadata.csv")
countries = pd.read_csv("https://raw.githubusercontent.com/mysociety/gaze/master/data/fips-10-4-to-iso-country-codes.csv")
```

The `stations` and the `countries` files are relatively small, so we can read them directly using `pd.read_csv`. However, the file containing all the information about temperature is quite large. Therefore, we will add the temperatures to the database in chunks. We will also need special formatting for the temperature file because it is organized in a difficult way. Let us prepare the temperature DataFrame so that the columns are Year, Month, and Temp for average temperature. To do so, we will create a function `prepare_df()` that takes in a DataFrame parameter `df`:

```python
def prepare_df(df):
    df = df.set_index(keys=["ID", "Year"])
    df = df.stack()
    df = df.reset_index()
    df = df.rename(columns = {"level_2"  : "Month" , 0 : "Temp"})
    df["Month"] = df["Month"].str[5:].astype(int)
    df["Temp"]  = df["Temp"] / 100
    return(df)
```

After defining this function, we can add the temperatures file into the database as chunks. To do so, we will create an iterable object and loop over the full DataFrame. 

To add to a database, we first need to establish a connection with the database with the function `sqlite3.connect()` which takes in a database name. If the database does not exist, then a new one is created. For this example, we will create a new database called `temps.db`. 

Now, we can add data to the database! Like described earlier, we will iterate over the full temperatures DataFrame. In the for loop, we will add a new column called "FIPS 10-4", which represents a unique code relating to each country. We will then add the DataFrame to `temps.db` using the function `to_sql`. This function creates a new table in a given database. After adding the temperatures data, we will add the stations and countries in a similar fashion, like so: 

```python
#create connection
conn = sqlite3.connect("temps.db")

#add temperatures to the database in chunks, add column for FIPS code for each chunk
df_iter = pd.read_csv("temps.csv", chunksize = 100000)
for df in df_iter:
    df = prepare_df(df)
    df["FIPS 10-4"] = df["ID"].str[0:2]
    df.to_sql("temperatures", conn, if_exists = "append", index = False) 

stations.to_sql("stations", conn, if_exists = "replace", index = False)
countries.to_sql("countries", conn, if_exists = "replace", index = False)

conn.close()
```

Don't forget to close the connection after you are done using the database! This is done using the function `close()`. Congrats! We have now made a database consisting of climate data. 

## §2. Write a Query Function

We will now query this database using `sqlite3 `. To manipulate data from databases, we first need to note the syntax for `sql` commands, which are represented as strings. In this case, we need to specify which columns from which tables we are taking data from, how we are joining tables together, and which specific information we want from the database. In particular, the following commands result in that: 
- `SELECT` specifies which columns we want `FROM` which table in the database
- `LEFT JOIN` joins the tables together based on specific criteria
- `WHERE` determines which data we want exactly from the database

The names of our tables are also quite long: "temperatures," "countries," and "stations." We can shorten these to T, C, and S respectively within the command as well. After specifiying the command for the database, we can then read this specific information from the database using the function `pd.read_sql_query()` which takes in the following parameters:
- `sql`: the `sql` command
- `con`: the connection to the database
- `params`: a list of parameters needed in the `sql` command
Since the `sql` command is a string, we cannot use variable names within the command. Therefore, we can create placeholders with `?` to denote where certain variables will be needed. `params` will then list the variables in order of necessity. 

For this example, let's create a function `query_climate_database()` with the following parameters:
- `country`, a string giving the name of a country for which data should be returned. 
- `year_begin` and `year_end`, two integers giving the earliest and latest years for which should be returned. 
- `month`, an integer giving the month of the year for which should be returned. 

The return value of `query_climate_database()` is a Pandas dataframe of temperature readings for the specified country, in the specified date range, in the specified month of the year. The resulting dataframe will have columns for: 

- The station name.
- The latitude of the station. 
- The longitude of the station. 
- The name of the country in which the station is located.
- The year in which the reading was taken. 
- The month in which the reading was taken. 
- The average temperature at the specified station during the specified year and month. 

With all this information, we are almost ready to create the function! Notice that the stations data and the countries data both have a column called "name," one in all capital letters and one that is capitalized respectively. To differentiate between the two, let's also rename the column "Name" to "Country" with the function `rename`. Now, we can create the query function! The full code is below: 

```python
def query_climate_database(country, year_begin, year_end, month):
    cmd = \
    """
    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp
    FROM temperatures T
    LEFT JOIN countries C ON C."FIPS 10-4" = T."FIPS 10-4"
    LEFT JOIN stations S ON S.id = T.id
    WHERE C.name = ? AND T.year >= ? AND T.year <= ? AND T.month = ?
    """
    
    with sqlite3.connect("temps.db") as conn:
        df = pd.read_sql_query(sql = cmd, con = conn, params = (country, year_begin, year_end, month) )
        df = df.rename(columns = {"Name" : "Country"})
        
    return df
```

We can use this function, as long as we specify a country, a range of years wanted, and a month! For example, let us get information about India from the years 1980 to 2020 in the month of January. Using our function, the code would look like this: 

```python
query_climate_database(country = "India",
                      year_begin = 1980,
                      year_end = 2020, 
                      month = 1)
```

## §3. Create a Geographic Scatter Function for Yearly Temperature Increases

Now, let's use this function to create a scatterplot that displays the average yearly change in temperature within a particular country. We will use `plotly`, `numpy`, and `LinearRegression` to do so. Let's import those modules right now first: 

```python
from plotly import express as px
import numpy as np
from sklearn.linear_model import LinearRegression
```

`LinearRegression` is a package we'll use so that we can calculate the average yearly change! It can create a regression line of data, so we will use the first coefficient of this regression line to analyze the yearly temperature increase. So, let's first define a function that computes this first coefficient that calculates the change in temperature per year. In a dataframe with "Year" and "Temp" columns, the "Year" values would be the x-axis and the "Temp" values would be the y-axis. Using functions from `LinearRegression`, we can create a function `coef` with the parameter `data_group` like so:

```python
def coef(data_group):
    x = data_group[["Year"]]
    y = data_group["Temp"] 
    LR = LinearRegression()
    LR.fit(x, y)
    return LR.coef_[0] #simple estimate of rate of change of temperature per year
```

Now we can easily calculate the yearly temperature change! With this calculatation, let's define a function that creates a plot of this information. This function `temperature_coefficient_plot` takes in the following parameters:
- `country`, a string giving the name of a country for which data should be returned. 
- `year_begin` and `year_end`, two integers giving the earliest and latest years for which should be returned. 
- `month`, an integer giving the month of the year for which should be returned. 
- `min_obs`, an integer that notes the minimum number of years of data needed for any station
- `**kwargs`, additional keyword arguments passed to `px.scatter_mapbox()`. These can be used to control the colormap used, the mapbox style, etc.

As mentioned above, we will use `px.scatter_mapbox()` to create the plot. Refer to documentation about this function for specifics about its parameters. This function `temperature_coefficient_plot` will return an interactive plot of the yearly changes in temperatures. 

To create this function, we'll need to create a dataframe containing relevant information, and then plot it. We can use our previous function `query_climate_database()` to create the necessary dataframe! After that, we can use the `transform()` function to create a new column based on information. In this case, we need to satisfy the `min_obs` parameter's specifications. So, let's use `np.size`, which can tell us the number of years of data a given climate station has. Then, let's filter out those that do not reach the minimum `min_obs` value. 

We will also need to create a new column for "Estimated Yearly Increase", which we can calulate using our `coef` function above. Let's round this number to four decimal places for readability. Lastly, we will specify the information that displays when a datapoint is hovered over. We will use the parameters `hover_name` and `hover_data` from `px.scatter_mapbox()` to display relevant information. All together, it will look like the following: 

```python
def temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, **kwargs):
    
    df = query_climate_database(country, year_begin, year_end, month)
    df["Total Years"] = df.groupby(["NAME"])["Year"].transform(np.size)
    df = df[(df["Total Years"]) >= min_obs]
    
    coefs = df.groupby(["NAME", "LATITUDE", "LONGITUDE"]).apply(coef)
    coefs = coefs.reset_index()
    coefs[0] = np.round(coefs[0], decimals = 4)
    coefs = coefs.rename(columns = {0: "Estimated Yearly Increase (°C)"})
    
    return px.scatter_mapbox(coefs, 
                            lat = "LATITUDE",
                            lon = "LONGITUDE",
                            hover_name = "NAME",
                            hover_data = ["LATITUDE", "LONGITUDE", "Estimated Yearly Increase (°C)"],
                            color = "Estimated Yearly Increase (°C)",
                            **kwargs)
```

We can now create this plot for any country and any range of years! Let's add to our example before, and graph the yearly change in temperatures between the years of 1980 and 2020 in the month of January for India like so:

```python
color_map = px.colors.diverging.RdGy_r # choose a colormap

fig = temperature_coefficient_plot("India", 1980, 2020, 1, 
                                   min_obs = 10,
                                   zoom = 2,
                                   mapbox_style="carto-positron",
                                   color_continuous_scale=color_map)

fig.show()
```

{% include india-HW0-example.html %}

## §4. Create Two More Interesting Figures

Let's use this knowledge to create two more interesting plots! 

First, let's create a plot that answers the following question: 

> What is the average temperature of a country throughout a specified month and year? 

To answer this question, we will need to query data from our database again. and plot using `plotly`. The syntax remains the same, except this time we want to specify a country, a month, and a year. To query this set of data, let's define a function `query_climate_database_month_year()` that takes in the parameters `country`, `year`, and `month`, like so: 

```python
def query_climate_database_month_year(country, year, month):
    cmd = \
    """
    SELECT S.name, C.name, T.year, T.month, T.temp, S.longitude, S.latitude
    FROM temperatures T
    LEFT JOIN countries C ON C."FIPS 10-4" = T."FIPS 10-4"
    LEFT JOIN stations S ON S.id = T.id
    WHERE T.year = ? AND T.month = ? AND C.name = ?
    """
    
    with sqlite3.connect("temps.db") as conn:
        df = pd.read_sql_query(sql = cmd, con = conn, params = (year, month, country) )
        df = df.rename(columns = {"Name" : "Country"})
        
    return df
```

This uses the same techniques as from when we defined `query_climate_database()` , but also takes into account the month of the data. For example, say we wanted to get a dataframe for the temperatures in Canada during August of 1984. We can use our newly defined function like so:

```python
query_climate_database_month_year("Canada", 1984, 8)
```

Using this query function, we can plot the information onto a map, like part 3, using `px.scatter_mapbox()`. The main difference is that we will change the hover data shown and we will change what determines the color. In this case, we want a different color to signify a different temperature. So, we will set the temperature to be the `color` parameter in `px.scatter_mapbox()`. We will also display the latititude, longitude, and temperature for the hover data. All together, we can define a new function `month_year_plot()` that takes in the parameters `country`, `year`, `month`, and `**kwargs`. The first three parameters are the same as `query_climate_database_month_year()` and `**kwargs` are any additional parameters associated with `px.scatter_mapbox()`. All together, the function will look like this: 

```python
def month_year_plot(country, year, month, **kwargs):
    
    df = query_climate_database_month_year(country, year, month)
    
    return px.scatter_mapbox(data_frame = df,
                            lat = "LATITUDE",
                            lon = "LONGITUDE",
                            hover_name = "NAME",
                            hover_data = ["LATITUDE", "LONGITUDE", "Temp"],
                            color = "Temp",
                            **kwargs)
```

Let's use this newly defined function to create a plot of temperatures in Canada during August 1984! We can use the function like so to get the following plot:

```python
fig = month_year_plot("Canada", 2001, 8,
                      zoom = 2,
                      mapbox_style = "carto-positron",
                      color_continuous_scale = color_map)

fig.show()

```
![hw1-plot1.png]({{ site.baseurl }}/images/hw1-plot1.png)

For our second plot, let's answer the following question: 

> What is the temperature of a country during a given year across all of its climate stations?

To answer this question, we will again need to create a query function of our database and plot the results with `plotly`. The syntax again remains the same, but instead, this time we want to specify a country and a year. To query this set of data, let's define a function `query_climate_database_country_year()` that takes in two parameters: `country` and `year`. These two parameters will be a string and an integer respectively, denoting which country and year you want data from. The function will be defined as so: 

```python
def query_climate_database_country_year(country, year):
    cmd = \
    """
    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp
    FROM temperatures T
    LEFT JOIN countries C ON C."FIPS 10-4" = T."FIPS 10-4"
    LEFT JOIN stations S ON S.id = T.id
    WHERE C.name = ? and T.year = ?
    """
    
    with sqlite3.connect("temps.db") as conn:
        df = pd.read_sql_query(sql = cmd, con = conn, params = (country, year) )
        df = df.rename(columns = {"Name" : "Country"})
        
    return df
```

We can now use this to query some data from the database! We can get the temperature information from Switzerland in the year 2001 like so: 

```python
query_climate_database_country_year("Switzerland", 2001)
```

To plot the information we want, we will use `plotly`, as described above. We want to create a scatterplot instead this time, plotting month against temperature! this will require the function `px.scatter`, the `plotly` function that helps us create a scatterplot. This function also has many parameters, which you can read about specifically on your own. I will use the following new parameters:
- `x`: the x-values of the graph
- `y`: the y-values of the graph
- `width`: the width of the graph
- `height`: the height of the graph
- `opacity`: a number between 0 and 1 that represents the opacity of each point
In addition to these parameters, I will use `color`, `hover_name`, and `hover_data` like we did with `px.scatter_mapbox()`.

In this case, I want to `x` to be the month and `y` to be the temperature at a given month. When hovering over the data, I want the name of the station to appear, as well as the temperature, the longitude, and the latitude. All together, it will look like this:

```python
def country_year_plot(country, year, **kwargs):
    
    df = query_climate_database_country_year(country, year)
    
    return px.scatter(data_frame = df,
                     x = "Month",
                     y = "Temp",
                     color = "NAME",
                     hover_name = "NAME",
                     hover_data = ["LONGITUDE", "LATITUDE", "Temp"],
                     **kwargs)


```
Using our Switzerland example from before, we can plot the temperatures in Switzerland during the year 2001 like so:

```python
fig = country_year_plot("Switzerland", 2001,
                      width = 750,
                      height = 300, 
                      opacity = 0.5)

# reduce whitespace
fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0})
# show the plot
fig.show()
```
![hw1-plot2.png]({{ site.baseurl }}/images/hw1-plot2.png)
