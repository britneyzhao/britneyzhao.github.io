---
layout: post
title: Blog Post 1 - Visualization of NOAA Climate Data
---

This blog post will explain how to create a database and visualize quantitative data from this database with Python using `sqlite3`. 

## §1. Creating the Database

First, we must create the database containing information about the NOAA Climate. To do so, we will first import the appropriate modules and read the data into `pandas` DataFrames. We will need `sqlite3` to create the actual database, so let's import this module now as well. For this example, we will import data about climate stations and countries like so: 

```python
import pandas as pd
import sqlite3

#read csv files
stations = pd.read_csv("https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/noaa-ghcn/station-metadata.csv")
countries = pd.read_csv("https://raw.githubusercontent.com/mysociety/gaze/master/data/fips-10-4-to-iso-country-codes.csv")
```

The `stations` and the `countries` files are relatively small, so we can read them directly using `pd.read_csv`. However, the file containing all the information about temperature is quite large. Therefore, we will add the temperatures to the database in chunks. We will also need special formatting for the temperature file because it is organized in a difficult way. Let us prepare the temperature DataFrame so that the columns are Year, Month, and Temp for average temperature. To do so, we will create a function `prepare_df()` that takes in a DataFrame parameter `df`:

```python
def prepare_df(df):
    df = df.set_index(keys=["ID", "Year"])
    df = df.stack()
    df = df.reset_index()
    df = df.rename(columns = {"level_2"  : "Month" , 0 : "Temp"})
    df["Month"] = df["Month"].str[5:].astype(int)
    df["Temp"]  = df["Temp"] / 100
    return(df)
```

After defining this function, we can add the temperatures file into the database as chunks. To do so, we will create an iterable object and loop over the full DataFrame. 

To add to a database, we first need to establish a connection with the database with the function `sqlite3.connect()` which takes in a database name. If the database does not exist, then a new one is created. For this example, we will create a new database called `temps.db`. 

Now, we can add data to the database! Like described earlier, we will iterate over the full temperatures DataFrame. In the for loop, we will add a new column called "FIPS 10-4", which represents a unique code relating to each country. We will then add the DataFrame to `temps.db` using the function `to_sql`. This function creates a new table in a given database. After adding the temperatures data, we will add the stations and countries in a similar fashion, like so: 

```python
#create connection
conn = sqlite3.connect("temps.db")

#add temperatures to the database in chunks, add column for FIPS code for each chunk
df_iter = pd.read_csv("temps.csv", chunksize = 100000)
for df in df_iter:
    df = prepare_df(df)
    df["FIPS 10-4"] = df["ID"].str[0:2]
    df.to_sql("temperatures", conn, if_exists = "append", index = False) 

stations.to_sql("stations", conn, if_exists = "replace", index = False)
countries.to_sql("countries", conn, if_exists = "replace", index = False)

conn.close()
```

Don't forget to close the connection after you are done using the database! This is done using the function `close()`. Congrats! We have now made a database consisting of climate data. 

## §2. Write a Query Function

We will now query this database using `sqlite3 `. To manipulate data from databases, we first need to note the syntax for `sql` commands, which are represented as strings. In this case, we need to specify which columns from which tables we are taking data from, how we are joining tables together, and which specific information we want from the database. In particular, the following commands result in that: 
- `SELECT` specifies which columns we want `FROM` which table in the database
- `LEFT JOIN` joins the tables together based on specific criteria
- `WHERE` determines which data we want exactly from the database

The names of our tables are also quite long: "temperatures," "countries," and "stations." We can shorten these to T, C, and S respectively within the command as well. After specifiying the command for the database, we can then read this specific information from the database using the function `pd.read_sql_query()` which takes in the following parameters:
- `sql`: the `sql` command
- `con`: the connection to the database
- `params`: a list of parameters needed in the `sql` command
Since the `sql` command is a string, we cannot use variable names within the command. Therefore, we can create placeholders with `?` to denote where certain variables will be needed. `params` will then list the variables in order of necessity. 

For this example, let's create a function `query_climate_database()` with the following parameters:
- `country`, a string giving the name of a country for which data should be returned. 
- `year_begin` and `year_end`, two integers giving the earliest and latest years for which should be returned. 
- `month`, an integer giving the month of the year for which should be returned. 

The return value of `query_climate_database()` is a Pandas dataframe of temperature readings for the specified country, in the specified date range, in the specified month of the year. The resulting dataframe will have columns for: 

- The station name.
- The latitude of the station. 
- The longitude of the station. 
- The name of the country in which the station is located.
- The year in which the reading was taken. 
- The month in which the reading was taken. 
- The average temperature at the specified station during the specified year and month. 

With all this information, we are almost ready to create the function! Notice that the stations data and the countries data both have a column called "name," one in all capital letters and one that is capitalized respectively. To differentiate between the two, let's also rename the column "Name" to "Country" with the function `rename`. Now, we can create the query function! The full code is below: 

```python
def query_climate_database(country, year_begin, year_end, month):
    cmd = \
    """
    SELECT S.name, S.latitude, S.longitude, C.name, T.year, T.month, T.temp
    FROM temperatures T
    LEFT JOIN countries C ON C."FIPS 10-4" = T."FIPS 10-4"
    LEFT JOIN stations S ON S.id = T.id
    WHERE C.name = ? AND T.year >= ? AND T.year <= ? AND T.month = ?
    """
    
    with sqlite3.connect("temps.db") as conn:
        df = pd.read_sql_query(sql = cmd, con = conn, params = (country, year_begin, year_end, month) )
        df = df.rename(columns = {"Name" : "Country"})
        
    return df
```


## §3. Create a Geographic Scatter Function for Yearly Temperature Increases



## §4. Create Two More Interesting Figures

Create at least two more complex and interesting interactive data visualizations using the same data set. In each case, you should construct your visualization from data obtained by querying the database that you created in §1. The code to construct each visualization should be wrapped in functions, such that a user could create visualizations for different parts of the data by calling these functions with different arguments. 

Alongside the plots, you should clearly state a question that the plot addresses, similar to the question that we posed in §3. The questions for your two additional plots should be meaningfully different from each other and from the §3 question. You will likely want to define different query functions for extracting data for these new visualizations.  

It is not necessary to create *geographic* plots for this part. Scatterplots, histograms, and line plots (among other choices) are all appropriate. Please make sure that they are complex, engaging, professional, and targeted to the questions you posed. In other words, *push yourself!* Don't hesitate to ask your peers or talk to me if you're having trouble coming up with questions or identifying plots that might be suitable for addressing those questions. 




